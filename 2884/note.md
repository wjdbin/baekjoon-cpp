## ⏰ 백준 2884번 알람 시계 오답 노트

---

### 📝 문제 요약 및 목표

* **제목:** 알람 시계 (Alarm Clock)
* **목표:** 현재 시각 **$H$시 $M$분**을 기준으로 **45분 전**의 시각을 계산하여 출력합니다.
* **입력:** 두 정수 **$H$** (시간, $0 \le H \le 23$) 와 **$M$** (분, $0 \le M \le 59$).
* **출력:** 45분 앞선 시각인 **$H'$**와 **$M'$**을 공백으로 구분하여 출력해야 합니다.
* **핵심 고려 사항:** **분($M$)이 45분 미만**일 때 시($H$)에서 1시간을 빌려와야 하며, 특히 **자정 경계($H=0$)**를 올바르게 처리해야 합니다.

---

### ❌ 원래 코드의 오류 분석

원래 코드는 $H=0$인 경우, 분($M$)의 값에 관계없이 **무조건 23시로 변경**하는 로직이었습니다. 이는 $M \ge 45$인 경우 시가 바뀌면 안 된다는 **경계 조건**을 놓친 것입니다.

#### 🔍 오류 발생 케이스

| 입력 시각 ($H$, $M$) | 45분 전 (정답) | 코드 실행 결과 ($H=0$일 때) | 이유 |
| :---: | :---: | :---: | :--- |
| **0시 50분** | 0시 5분 | 23시 65분 | $M=50$은 **45분 이상**이므로 시는 $0$으로 유지되어야 하는데, $H=0$ 조건 때문에 **23시**로 잘못 변경됨. |

**결론:** **조건문의 순서가 잘못**되었습니다. 분($M$)을 먼저 기준(45분 이상/미만)으로 삼아 로직을 구성했어야 합니다.

---

### ✅ 수정된 올바른 로직 (2가지 방법)

#### 1️⃣ 방법 1: 조건문 분기 처리 (Case by Case)

**분($M$)**을 기준으로 조건을 나누고, **$M < 45$인 경우**에만 시($H$)의 0시 경계를 처리합니다.

```cpp
#include <iostream>
using namespace std;

int main()
{
    int H, M;
    cin >> H >> M;
    
    // 1. 분(M)이 45분 이상인 경우
    if (M >= 45) 
    {
        printf("%d %d", H, M - 45);
    }
    // 2. 분(M)이 45분 미만인 경우 (시가 1 감소해야 함)
    else 
    {
        // 2-1. H가 0인 경우: 23시로 변경
        if (H == 0)
        {
            printf("%d %d", 23, M + 15); 
        }
        // 2-2. H가 0이 아닌 경우: H-1시로 변경
        else
        {
            printf("%d %d", H - 1, M + 15);
        }
    }
    
    return 0;
}
```

---

#### 2️⃣ 방법 2: 전체 분(minute)으로 일괄 처리 (가장 깔끔함)

모든 시각을 **분 단위**로 변환하여 덧셈/뺄셈을 수행하고, 결과를 **모듈러 연산**으로 처리합니다.

```cpp
#include <iostream>
using namespace std;

int main()
{
    int H, M;
    cin >> H >> M;
    
    // 1. 전체 분으로 변환 및 45분 빼기
    int new_minutes = H * 60 + M - 45;
    
    // 2. 결과가 음수일 경우 (자정을 넘긴 경우) 1440분(24시간) 더하기
    if (new_minutes < 0)
    {
        new_minutes += 1440; 
    }
    
    // 3. 다시 시와 분으로 변환하여 출력
    printf("%d %d", new_minutes / 60, new_minutes % 60);
    
    return 0;
}
```

---

### 🧠 핵심 교훈

시간과 같은 **주기적인 값**을 다룰 때는 **모든 단위를 가장 작은 단위(분)**로 통일하여 계산하는 것이 **경계 조건 오류**를 방지하는 가장 안전한 방법입니다.

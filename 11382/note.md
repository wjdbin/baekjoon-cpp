## ✅ 올바른 접근 및 수정 (백준 11382)

### 💡 문제의 핵심: 데이터 범위와 자료형의 한계

이 문제의 정답률이 90%가 아닌 60%대인 이유는, 단순한 덧셈이 아니라 **데이터의 범위**에 함정이 있기 때문입니다.

문제에서 주어진 A, B, C의 입력 범위는 **$1 \le A, B, C \le 10^{12}$** (1조)입니다.
따라서 세 수의 합은 최대 **$3 \times 10^{12}$** (3조)에 달할 수 있습니다.

---

### ❌ 오답 원인 분석

#### 1. `int` 자료형을 사용한 경우

* 일반적인 32비트 환경에서 `int` 자료형이 저장할 수 있는 최대값은 약 21억 ($2,147,483,647$ 또는 $2 \times 10^9$)입니다.
* 이는 문제의 최대 입력값인 1조($10^{12}$)는 물론, 세 수의 합인 3조($3 \times 10^{12}$)를 담기에 턱없이 부족합니다.
* `int`의 범위를 넘어선 값이 입력되면 **정수 오버플로우(Integer Overflow)**가 발생하여, 값이 비정상적으로 순환하거나 (음수가 되기도 함) 잘못된 결과가 나옵니다.

#### 2. `double` 자료형을 사용한 경우

* `double`은 매우 큰 수를 표현할 수는 있지만, 이는 **실수(부동소수점)**를 다루기 위한 자료형입니다.
* **문제점 (1) - 지수 표기법:** `cout`은 매우 큰 `double` 값을 출력할 때 자동으로 **지수 표기법(Scientific Notation)**을 사용합니다. (예: `3e+12`) 백준 채점 시스템은 `3000000000000`이라는 정확한 정수 문자열을 원하므로, `3e+12`는 '출력 형식이 잘못되었습니다'로 오답 처리됩니다.
* **문제점 (2) - 정밀도 손실:** `double`은 유효 숫자의 개수에 한계가 있습니다. 매우 큰 정수를 저장할 때 끝자리의 정밀도가 손실될 수 있어, 이 문제의 의도(정확한 정수 연산)와 맞지 않습니다.

---

### 🔑 해결 전략: `long long`

위의 두 문제를 모두 해결하는 C++의 표준 정수 자료형이 바로 **`long long int`** (또는 `long long`)입니다.

* `long long`은 **64비트** 정수 자료형입니다.
* 저장할 수 있는 최대 범위는 약 **$9 \times 10^{18}$** (922경)입니다.
* 이 범위는 문제에서 요구하는 최대 합인 3조($3 \times 10^{12}$)를 저장하고도 압도적으로 넉넉합니다.

따라서 이 문제는 C++의 `int`가 모든 정수를 대표하지 않으며, **문제의 제약 조건을 확인하여 알맞은 범위의 자료형을 선택하는 능력**을 요구하는 것이 핵심입니다.
